CREATE OR REPLACE PACKAGE BODY NO IS
  MAX_ROW INTEGER := 10000000;
  -- MAX_DECIMALS INTEGER := 8;
  ---------------------------------------
  --
  --   FUNCTION FOR A NEW MATRIX CREATION
  --
  --
  FUNCTION ZEROS(Y IN INTEGER, X IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN MATRIX(Y, X, 0);
  END;

  FUNCTION ZEROS(Y IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN ARRAY(Y, 0);
  END;

  FUNCTION ONES(Y IN INTEGER, X IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN MATRIX(Y, X, 1);
  END;

  FUNCTION ONES(Y IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN ARRAY(Y, 1);
  END;

  FUNCTION EMPTY(Y IN INTEGER, X IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN MATRIX(Y, X, CAST(NULL AS NUMBER));
  END;

  FUNCTION EMPTY RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN MATRIX;
  END;

  FUNCTION EMPTY(Y IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN ARRAY(Y, CAST(NULL AS NUMBER));
  END;
  FUNCTION MATRIX RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    MATRIX_INFO  MATRIX_INFO_ROW;
    MATRIX_DATA  MATRIX_DATA_TABLE;
    MATRIX       T_MATRIX;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    MATRIX_DATA := MATRIX_DATA_TABLE();
    MATRIX_INFO := MATRIX_INFO_ROW('', 0, 0, 0, SYSDATE);

    MATRIX := T_MATRIX(MATRIX_INFO, MATRIX_DATA);

    RETURN MATRIX;
  END;
  FUNCTION MATRIX(Y IN INTEGER, X IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN MATRIX(Y, X, CAST(NULL AS NUMBER));
  END;

  ---------------------------------------
  --
  --   FUNCTION FOR A NEW MATRIX CREATION WITH AS DEFAULT VALUE
  --
  --
  FUNCTION MATRIX(Y IN INTEGER, X IN INTEGER, DEFAULT_VALUE IN INTEGER)
    RETURN T_MATRIX IS
    MATRIX_INFO  MATRIX_INFO_ROW;
    MATRIX_DATA  MATRIX_DATA_TABLE;
    MATRIX       T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    MATRIX_DATA := MATRIX_DATA_TABLE();
    MATRIX_INFO := MATRIX_INFO_ROW('', 0, Y, X, SYSDATE);

    FOR Y_INDEX IN 1 .. Y LOOP
      FOR X_INDEX IN 1 .. X LOOP

        MATRIX_DATA.EXTEND;
        MATRIX_DATA(MATRIX_DATA.COUNT) := MATRIX_DATA_ROW(Y_INDEX,
                                                          X_INDEX,
                                                          DEFAULT_VALUE);

      END LOOP;
    END LOOP;

    MATRIX := T_MATRIX(MATRIX_INFO, MATRIX_DATA);

    RETURN MATRIX;
  END;

  FUNCTION ARANGE(A IN INTEGER) RETURN T_MATRIX IS
    MATRIX_OUT   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    B            INTEGER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    MATRIX_OUT := MATRIX(1, A);

    B := 0;
    FOR I IN 1 .. A LOOP
      MATRIX_OUT.DATA(I).VALUE := B;
      B := B + 1;
    END LOOP;

    RETURN MATRIX_OUT;
  END;

  FUNCTION ARANGE(A IN INTEGER, A2 IN INTEGER, A3 IN FLOAT) RETURN T_MATRIX IS
    MATRIX_OUT   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    B            FLOAT;
    INICIO       INTEGER;
    NROW         INTEGER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    INICIO := 1;
    B      := A;
    NROW   := 1;
    WHILE INICIO <= ((A2 - A) / A3) LOOP
      NROW   := NROW + 1;
      INICIO := INICIO + 1;
      B      := B + A3;
    END LOOP;

    MATRIX_OUT := MATRIX(1, NROW);

    B      := A;
    INICIO := 1;

    WHILE INICIO <= NROW LOOP
      MATRIX_OUT.DATA(INICIO).VALUE := B;
      INICIO := INICIO + 1;
      B := B + A3;
    END LOOP;

    RETURN MATRIX_OUT;
  END;

  FUNCTION LINSPACE(A IN FLOAT, A2 IN FLOAT, A3 IN FLOAT) RETURN T_MATRIX IS
    MATRIX_OUT   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    B            FLOAT;
    INICIO       INTEGER;
    NROW         INTEGER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN ARANGE(A, A2, (A2 - A) / (A3 - 1));
  END;

  FUNCTION MATRIX(Y IN T_MATRIX, A IN C) RETURN T_MATRIX IS
    MATRIX_OUT   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    MATRIX_OUT := MATRIX(Y.INFO.NROW, Y.INFO.NCOL);

    FOR I IN 1 .. (A.COUNT) LOOP
      MATRIX_OUT.DATA(I).VALUE := A(I);
    END LOOP;

    RETURN MATRIX_OUT;
  END;

  FUNCTION FLIP(Y IN T_MATRIX) RETURN T_MATRIX IS
    MATRIX_OUT   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    MAXIMO       INTEGER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    MATRIX_OUT := Y;
    MAXIMO     := NCOL(Y) * NROW(Y);

    FOR I IN 0 .. MAXIMO - 1 LOOP
      MATRIX_OUT.DATA(MAXIMO - I).VALUE := Y.DATA(I + 1).VALUE;
    END LOOP;

    RETURN MATRIX_OUT;
  END;

  FUNCTION MATRIX(Y IN INTEGER, X IN INTEGER, A IN C) RETURN T_MATRIX IS
    MATRIX_OUT   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    IF X * Y <> (A.COUNT) THEN
      RAISE MATRIX_ERROR;
    END IF;

    MATRIX_OUT := MATRIX(Y, X);

    FOR I IN 1 .. (A.COUNT) LOOP
      MATRIX_OUT.DATA(I).VALUE := A(I);
    END LOOP;

    RETURN MATRIX_OUT;
  END;

  FUNCTION MATRIX(A IN C) RETURN T_MATRIX IS
    MATRIX_OUT   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    MATRIX_OUT := MATRIX(1, A.COUNT);

    FOR I IN 1 .. (A.COUNT) LOOP
      MATRIX_OUT.DATA(I).VALUE := A(I);
    END LOOP;

    RETURN MATRIX_OUT;
  END;

  FUNCTION ARRAY RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN MATRIX();
  END;
  ---------------------------------------
  --
  --   FUNCTION FOR A NEW MATRIX CREATION
  --
  --
  FUNCTION ARRAY(X IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN MATRIX(1, X, CAST(NULL AS NUMBER));
  END;

  ---------------------------------------
  --
  --   FUNCTION FOR A NEW MATRIX CREATION WITH AS DEFAULT VALUE
  --
  --
  FUNCTION ARRAY(X IN INTEGER, DEFAULT_VALUE IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN MATRIX(1, X, DEFAULT_VALUE);
  END;

  FUNCTION ARRAY(X IN INTEGER, A IN C) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN MATRIX(1, X, A);
  END;
  FUNCTION CUT(M  IN T_MATRIX,
               Y1 IN INTEGER,
               X1 IN INTEGER,
               Y2 IN INTEGER,
               X2 IN INTEGER) RETURN T_MATRIX IS
    NEW_MATRIX   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    NEW_MATRIX := MATRIX();

    IF X2 > (M.INFO.NCOL) OR Y2 > (M.INFO.NROW) OR X1 > X2 OR Y1 > Y2 OR
       X1 < 0 OR X2 < 0 OR Y1 < 0 OR Y2 < 0 THEN
      RAISE MATRIX_ERROR;
    END IF;

    SELECT MATRIX_DATA_ROW(Y - Y1 + 1, X - X1 + 1, VALUE)
      BULK COLLECT
      INTO NEW_MATRIX.DATA
      FROM TABLE(M.DATA)
     WHERE Y >= Y1
       AND Y <= Y2
       AND X >= X1
       AND X <= X2;

    SELECT MAX(X) INTO NEW_MATRIX.INFO.NCOL FROM TABLE(NEW_MATRIX.DATA);

    SELECT MAX(Y) INTO NEW_MATRIX.INFO.NROW FROM TABLE(NEW_MATRIX.DATA);

    RETURN NEW_MATRIX;

  END;

  FUNCTION ADD(M IN T_MATRIX, NEW_VALUE IN NUMBER) RETURN T_MATRIX IS
    NEW_MATRIX   T_MATRIX;
    NCOL         NUMBER;
    NROW         NUMBER;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    NEW_MATRIX := MATRIX();
    NCOL       := M.INFO.NCOL;
    NROW       := M.INFO.NROW;

    SELECT MATRIX_DATA_ROW(Y, X, VALUE)
      BULK COLLECT
      INTO NEW_MATRIX.DATA
      FROM (SELECT 1 Y, ROWNUM X, VALUE
              FROM TABLE(M.DATA)
            UNION
            SELECT 1, NCOL * NROW + 1, NEW_VALUE
              FROM DUAL);

    SELECT MAX(X) INTO NEW_MATRIX.INFO.NCOL FROM TABLE(NEW_MATRIX.DATA);

    SELECT MAX(Y) INTO NEW_MATRIX.INFO.NROW FROM TABLE(NEW_MATRIX.DATA);

    RETURN NEW_MATRIX;

  END;

  FUNCTION GETROWS(M IN T_MATRIX, Y1 IN INTEGER, Y2 IN INTEGER DEFAULT 0)
    RETURN T_MATRIX IS
    NEW_MATRIX   T_MATRIX;
    NEW_Y2       INTEGER;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    NEW_MATRIX := MATRIX();

    IF Y2 = 0 THEN
      NEW_Y2 := Y1;
    ELSE
      NEW_Y2 := Y2;
    END IF;

    SELECT MATRIX_DATA_ROW(Y - Y1 + 1, X, VALUE)
      BULK COLLECT
      INTO NEW_MATRIX.DATA
      FROM TABLE(M.DATA)
     WHERE Y >= Y1
       AND Y <= NEW_Y2;

    SELECT MAX(X) INTO NEW_MATRIX.INFO.NCOL FROM TABLE(NEW_MATRIX.DATA);

    SELECT MAX(Y) INTO NEW_MATRIX.INFO.NROW FROM TABLE(NEW_MATRIX.DATA);

    RETURN NEW_MATRIX;

  END;

  FUNCTION GETCOLS(M IN T_MATRIX, X1 IN INTEGER, X2 IN INTEGER DEFAULT 0)
    RETURN T_MATRIX IS
    NEW_MATRIX   T_MATRIX;
    NEW_X2       INTEGER;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    NEW_MATRIX := MATRIX();

    IF X2 = 0 THEN
      NEW_X2 := X1;
    ELSE
      NEW_X2 := X2;
    END IF;

    SELECT MATRIX_DATA_ROW(Y, X - X1 + 1, VALUE)
      BULK COLLECT
      INTO NEW_MATRIX.DATA
      FROM TABLE(M.DATA)
     WHERE X >= X1
       AND X <= NEW_X2;

    SELECT MAX(X) INTO NEW_MATRIX.INFO.NCOL FROM TABLE(NEW_MATRIX.DATA);

    SELECT MAX(Y) INTO NEW_MATRIX.INFO.NROW FROM TABLE(NEW_MATRIX.DATA);

    RETURN NEW_MATRIX;

  END;

  FUNCTION DIFFERENCE(M IN T_MATRIX) RETURN T_MATRIX IS
    NEW_MATRIX   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    NEW_MATRIX := MATRIX();

    SELECT MATRIX_DATA_ROW(Y, ROWNUM, VALUE)
      BULK COLLECT
      INTO NEW_MATRIX.DATA
      FROM (SELECT DISTINCT 1 Y, NULL X, VALUE FROM TABLE(M.DATA));

    SELECT MAX(X) INTO NEW_MATRIX.INFO.NCOL FROM TABLE(NEW_MATRIX.DATA);

    SELECT MAX(Y) INTO NEW_MATRIX.INFO.NROW FROM TABLE(NEW_MATRIX.DATA);

    RETURN NEW_MATRIX;

  END;

  FUNCTION SORT(M IN T_MATRIX) RETURN T_MATRIX IS
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN ORDERBY(M);

  END;

  FUNCTION ORDERBY(M IN T_MATRIX, TYPE IN VARCHAR2 DEFAULT 'ASC')
    RETURN T_MATRIX IS
    NEW_MATRIX   T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    NCOL         INTEGER;
    NROW         INTEGER;
    I            INTEGER;
    J            INTEGER;
    CONTEO       INTEGER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    NEW_MATRIX := MATRIX();
    NCOL       := M.INFO.NCOL;
    NROW       := M.INFO.NROW;

    IF UPPER(TYPE) = 'ASC' THEN

      SELECT MATRIX_DATA_ROW(0, 0, VALUE)
        BULK COLLECT
        INTO NEW_MATRIX.DATA
        FROM TABLE(M.DATA)
       ORDER BY VALUE ASC;

    ELSE

      SELECT MATRIX_DATA_ROW(0, 0, VALUE)
        BULK COLLECT
        INTO NEW_MATRIX.DATA
        FROM TABLE(M.DATA)
       ORDER BY VALUE DESC;

    END IF;

    CONTEO := 1;
    FOR I IN 1 .. NROW LOOP
      FOR J IN 1 .. NCOL LOOP
        NEW_MATRIX.DATA(CONTEO).Y := I;
        NEW_MATRIX.DATA(CONTEO).X := J;
        CONTEO := CONTEO + 1;
      END LOOP;
    END LOOP;

    SELECT MAX(X) INTO NEW_MATRIX.INFO.NCOL FROM TABLE(NEW_MATRIX.DATA);

    SELECT MAX(Y) INTO NEW_MATRIX.INFO.NROW FROM TABLE(NEW_MATRIX.DATA);

    RETURN NEW_MATRIX;

  END;

  ---------------------------------------
  --
  --   FUNCTION FOR A NEW MATRIX CREATION WITH AS DEFAULT VALUE
  --
  --
  FUNCTION EXTEND(M IN T_MATRIX, Y IN INTEGER, X IN INTEGER) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN EXTEND(M, Y, X, NULL);
  END;

  ---------------------------------------
  --
  --   FUNCTION FOR A NEW MATRIX CREATION WITH AS DEFAULT VALUE
  --
  --
  FUNCTION EXTEND(M             IN T_MATRIX,
                  Y             IN INTEGER,
                  X             IN INTEGER,
                  DEFAULT_VALUE IN INTEGER) RETURN T_MATRIX IS
    NEW_MATRIX   T_MATRIX;
    ORDER_MATRIX T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    NEW_MATRIX   := M;
    ORDER_MATRIX := MATRIX();

    FOR Y_INDEX IN 1 .. M.INFO.NROW LOOP
      FOR X_INDEX IN M.INFO.NCOL + 1 .. X LOOP
        NEW_MATRIX.DATA.EXTEND;
        NEW_MATRIX.DATA(NEW_MATRIX.DATA.COUNT) := MATRIX_DATA_ROW(Y_INDEX,
                                                                  X_INDEX,
                                                                  DEFAULT_VALUE);
      END LOOP;
    END LOOP;

    FOR Y_INDEX IN M.INFO.NROW + 1 .. Y LOOP
      FOR X_INDEX IN 1 .. X LOOP
        NEW_MATRIX.DATA.EXTEND;
        NEW_MATRIX.DATA(NEW_MATRIX.DATA.COUNT) := MATRIX_DATA_ROW(Y_INDEX,
                                                                  X_INDEX,
                                                                  DEFAULT_VALUE);
      END LOOP;
    END LOOP;

    SELECT MATRIX_DATA_ROW(Y, X, VALUE)
      BULK COLLECT
      INTO ORDER_MATRIX.DATA
      FROM TABLE(NEW_MATRIX.DATA)
     ORDER BY Y, X ASC;

    SELECT MAX(X)
      INTO ORDER_MATRIX.INFO.NCOL
      FROM TABLE(ORDER_MATRIX.DATA);

    SELECT MAX(Y)
      INTO ORDER_MATRIX.INFO.NROW
      FROM TABLE(ORDER_MATRIX.DATA);

    RETURN ORDER_MATRIX;
  END;
  ---------------------------------------
  --
  --   FUNCTION FOR A NEW RANDOM MATRIX
  --
  --
  FUNCTION RANDOM(Y         IN INTEGER,
                  X         IN INTEGER,
                  MIN_VALUE IN INTEGER DEFAULT 0,
                  MAX_VALUE IN INTEGER DEFAULT 1,
                  DECIMALS  IN INTEGER DEFAULT 4) RETURN T_MATRIX IS
    R_MATRIX     T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    IF MIN_VALUE > MAX_VALUE THEN
      RAISE MATRIX_ERROR;
    END IF;

    IF Y NOT BETWEEN 1 AND MAX_ROW THEN
      RAISE MATRIX_ERROR;
    END IF;

    R_MATRIX := MATRIX(Y, X, 0);
    FOR J IN 1 .. Y LOOP
      FOR I IN 1 .. X LOOP
        ASSIGN(R_MATRIX,
               J,
               I,
               ROUND(DBMS_RANDOM.VALUE(MIN_VALUE, MAX_VALUE), DECIMALS));
      END LOOP;
    END LOOP;

    RETURN R_MATRIX;
  END;
  ---------------------------------------
  --
  --   FUNCTION FOR A NEW IDENTITY MATRIX CREATION
  --
  --
  FUNCTION IDENTITY(Y IN INTEGER) RETURN T_MATRIX IS
    I_MATRIX     T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    IF Y NOT BETWEEN 1 AND MAX_ROW THEN
      RAISE MATRIX_ERROR;
    END IF;

    I_MATRIX := MATRIX(Y, Y, 0);
    FOR J IN 1 .. Y LOOP
      ASSIGN(I_MATRIX, J, J, 1);
    END LOOP;

    RETURN I_MATRIX;
  END;

  procedure ASSIGN(MATRIX_IN IN OUT T_MATRIX,
                   Y         IN INTEGER,
                   X         IN INTEGER,
                   VALUE     IN NUMBER) IS

  BEGIN

    MATRIX_IN.DATA((Y - 1) * MATRIX_IN.INFO.NCOL + X).VALUE := VALUE;
  
  END;
  
  function ASSIGN(MATRIX_IN IN OUT T_MATRIX,
                   Y         IN INTEGER,
                   X         IN INTEGER,
                   VALUE     IN NUMBER) return t_matrix IS

  BEGIN

    MATRIX_IN.DATA((Y - 1) * MATRIX_IN.INFO.NCOL + X).VALUE := VALUE;

  return MATRIX_IN;
  
  END;

  ---------------------------------------
  --
  --  FUNCTION FOR GET A CELL
  --
  --
  FUNCTION GET(MATRIX_IN IN T_MATRIX, Y IN INTEGER, X IN INTEGER)
    RETURN NUMBER IS

    /*    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);*/
  BEGIN

    -- EXIT CLAUSE IF THE DATA ARE WRONG:
    /*    IF Y * X > MATRIX_IN.INFO.NROW * MATRIX_IN.INFO.NCOL THEN
      RAISE MATRIX_ERROR;
    END IF;*/

    RETURN MATRIX_IN.DATA((Y - 1) * MATRIX_IN.INFO.NCOL + X).VALUE;

  END;

  FUNCTION RESHAPE(MATRIX_IN IN T_MATRIX, Y IN INTEGER, X IN INTEGER)
    RETURN T_MATRIX IS
  BEGIN

    RETURN MATRIX(Y, X, TO_LIST(MATRIX_IN));

  END;

  FUNCTION TO_LIST(MATRIX_IN IN T_MATRIX) RETURN C IS
    LIST C;
  BEGIN

    LIST := C();

    FOR I IN 1 .. MATRIX_IN.DATA.COUNT LOOP
      LIST.EXTEND;
      LIST(I) := MATRIX_IN.DATA(I).VALUE;
    END LOOP;

    RETURN LIST;

  END;

  ---------------------------------------
  --
  --  FUNCTION PRINT THE MATRIX IN DBMS_OUTPUT
  --
  --
  PROCEDURE PRINT(A IN C)  IS
    CADENA   VARCHAR2(255);
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    CADENA := CADENA || '(';

    FOR I IN 1 .. (A.COUNT) LOOP
       CADENA := CADENA || A(I);
      IF  I <> A.COUNT THEN
          CADENA := CADENA || ',';
      END IF;
    END LOOP;

    CADENA := CADENA || ')';

    PRINT(CADENA);

  END;

  PROCEDURE PRINT(TEXTO IN VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(TEXTO);
  END;

  PROCEDURE PRINT(A         IN T_MATRIX,
                  SEPARADOR IN VARCHAR2 DEFAULT '|',
                  DECIMALES IN INTEGER DEFAULT 1) IS
    LINE         VARCHAR2(1000);
    MAXIMO_1     INTEGER;
    MAXIMO_2     INTEGER;
    TOTAL_Y      INTEGER;
    TOTAL_X      INTEGER;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    MAXIMO_1 := 0;
    MAXIMO_2 := 0;
    TOTAL_Y  := 0;

    --IF A IS NULL THEN BREAK; END IF;

    FOR I IN 1 .. A.INFO.NROW LOOP
      MAXIMO_1 := GREATEST(LENGTH(NVL(TO_CHAR(ROUND(GET(A, I, 1), DECIMALES)),
                                      'null')),
                           MAXIMO_1);
      FOR J IN 2 .. A.INFO.NCOL LOOP
        MAXIMO_2 := GREATEST(LENGTH(NVL(TO_CHAR(ROUND(GET(A, I, J),
                                                      DECIMALES)),
                                        'null')),
                             MAXIMO_2);
      END LOOP;
      TOTAL_Y := 1 + TOTAL_Y;
      IF TOTAL_Y = 20 THEN
        EXIT;
      END IF;
    END LOOP;

    TOTAL_Y := 0;

    FOR I IN 1 .. A.INFO.NROW LOOP
      LINE    := SEPARADOR ||
                 LPAD(NVL(TO_CHAR(ROUND(GET(A, I, 1), DECIMALES)), 'null'),
                      MAXIMO_1 + 1);
      TOTAL_X := 0;
      FOR J IN 2 .. A.INFO.NCOL LOOP

        LINE    := LINE || ' ' ||
                   LPAD(NVL(TO_CHAR(ROUND(GET(A, I, J), DECIMALES)), 'null'),
                        MAXIMO_2 + 1);
        TOTAL_X := 1 + TOTAL_X;
        IF TOTAL_X = 20 THEN
          EXIT;
        END IF;
      END LOOP;

      IF TOTAL_X < 20 THEN
        LINE := LINE || ' ' || SEPARADOR;
      END IF;

      DBMS_OUTPUT.PUT_LINE(LINE);
      TOTAL_Y := 1 + TOTAL_Y;
      IF TOTAL_Y = 20 THEN
        EXIT;
      END IF;

    END LOOP;

    IF TOTAL_Y >= 20 OR TOTAL_X >= 20 THEN
      DBMS_OUTPUT.PUT_LINE('');
      DBMS_OUTPUT.PUT_LINE(' only 20x20 first cells displayed ');
    END IF;

    DBMS_OUTPUT.PUT_LINE('');

  END;

  PROCEDURE PRINT_DEBUG(A IN T_MATRIX) IS
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    DBMS_OUTPUT.PUT_LINE('i,j,value');
    DBMS_OUTPUT.PUT_LINE('---------');

    FOR I IN 1 .. A.DATA.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE(A.DATA(I).Y || ',' || A.DATA(I).X || ',' || A.DATA(I).VALUE);
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('ncol: ' || A.INFO.NCOL);
    DBMS_OUTPUT.PUT_LINE('nrow: ' || A.INFO.NROW);
    DBMS_OUTPUT.PUT_LINE('---------');

  END;

  ---------------------------------------
  --
  -- EQUAL
  --
  --
  FUNCTION EQUAL(A IN T_MATRIX, B IN T_MATRIX) RETURN INTEGER IS
    RESULTADO    INTEGER;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    SELECT COUNT(*)
      INTO RESULTADO
      FROM (SELECT * FROM TABLE(A.DATA) MINUS SELECT * FROM TABLE(B.DATA));

    IF RESULTADO = 0 THEN
      RETURN 1; --TRUE
    ELSE
      RETURN 0; -- FALSE
    END IF;
  END;
  ---------------------------------------
  --
  -- MATRIX SUBTRAC
  --
  --
  FUNCTION SUB(A IN T_MATRIX, B IN T_MATRIX) RETURN T_MATRIX IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    IF NOT (NCOL(A) = NCOL(B) AND NROW(A) = NROW(B)) THEN
      RAISE MATRIX_ERROR;
    END IF;

    C := MATRIX();

    SELECT MATRIX_DATA_ROW(Y, X, VALUE)
      BULK COLLECT
      INTO C.DATA
      FROM (SELECT A.Y, A.X, (A.VALUE - B.VALUE) VALUE
              FROM TABLE(A.DATA) A, TABLE(B.DATA) B
             WHERE A.Y = B.Y
               AND A.X = B.X);

    SELECT MAX(X) INTO C.INFO.NCOL FROM TABLE(C.DATA);

    SELECT MAX(Y) INTO C.INFO.NROW FROM TABLE(C.DATA);

    RETURN C;

  END;

  FUNCTION PUT(A IN T_MATRIX, B IN T_MATRIX, X2 IN INTEGER, Y2 IN INTEGER)
    RETURN T_MATRIX IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    C := MATRIX();

    SELECT MATRIX_DATA_ROW(Y, X, VALUE)
      BULK COLLECT
      INTO C.DATA
      FROM (SELECT A.Y, A.X, NVL(B.VALUE, A.VALUE) VALUE
              FROM TABLE(A.DATA) A
              LEFT JOIN TABLE(B.DATA) B
                ON (A.Y = B.Y + Y2 - 1 AND A.X = B.X + X2 - 1))
     ORDER BY Y, X;

    SELECT MAX(X) INTO C.INFO.NCOL FROM TABLE(C.DATA);

    SELECT MAX(Y) INTO C.INFO.NROW FROM TABLE(C.DATA);

    RETURN C;

  END;
  FUNCTION SUM(A IN T_MATRIX, B IN T_MATRIX) RETURN T_MATRIX IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    C := MATRIX();

    IF NOT (NCOL(A) = NCOL(B) AND NROW(A) = NROW(B)) THEN
      RAISE MATRIX_ERROR;
    END IF;

    SELECT MATRIX_DATA_ROW(Y, X, VALUE)
      BULK COLLECT
      INTO C.DATA
      FROM (SELECT A.Y, A.X, (A.VALUE + B.VALUE) VALUE
              FROM TABLE(A.DATA) A, TABLE(B.DATA) B
             WHERE A.Y = B.Y
               AND A.X = B.X);

    SELECT MAX(X) INTO C.INFO.NCOL FROM TABLE(C.DATA);

    SELECT MAX(Y) INTO C.INFO.NROW FROM TABLE(C.DATA);

    RETURN C;

  END;

  FUNCTION SUM(A IN T_MATRIX, B IN NUMBER) RETURN T_MATRIX IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    C := MATRIX();

    SELECT MATRIX_DATA_ROW(Y, X, VALUE + B)
      BULK COLLECT
      INTO C.DATA
      FROM TABLE(A.DATA) A;

    C.DATA := A.DATA;

    RETURN C;

  END;

  ---------------------------------------
  --
  -- MATRIX NCOL
  --
  --
  FUNCTION DIM(A IN T_MATRIX) RETURN INTEGER IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN A.INFO.NCOL * A.INFO.NROW;

  END;

  FUNCTION SHAPE(A IN T_MATRIX) RETURN C IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN C(A.INFO.NCOL, A.INFO.NROW);

  END;

  FUNCTION NCOL(A IN T_MATRIX) RETURN INTEGER IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN A.INFO.NCOL;

  END;

  ---------------------------------------
  --
  -- MATRIX NROW
  --
  --
  FUNCTION NROW(A IN T_MATRIX) RETURN INTEGER IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN A.INFO.NROW;

  END;

  ---------------------------------------
  --
  -- MATRIX MULTIPLY
  --
  --
  FUNCTION MUL_CELLS(A IN T_MATRIX, B IN INTEGER) RETURN T_MATRIX IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    C := MATRIX();

    SELECT MATRIX_DATA_ROW(Y, X, VALUE * B)
      BULK COLLECT
      INTO C.DATA
      FROM TABLE(A.DATA) A;

    C.INFO := A.INFO;

    RETURN C;

  END;

  ---------------------------------------
  --
  -- MATRIX MULTIPLY
  --
  --

  FUNCTION MUL_CELLS(A IN T_MATRIX, B IN T_MATRIX) RETURN T_MATRIX IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    C := MATRIX();

    IF NOT (NCOL(A) = NCOL(A) AND NROW(B) = NROW(B) ) THEN
      RAISE MATRIX_ERROR;
    END IF;


     SELECT MATRIX_DATA_ROW(A.Y, B.X, (A.VALUE * B.VALUE))
        BULK COLLECT
        INTO C.DATA
        FROM TABLE(A.DATA) A, TABLE(B.DATA) B
       WHERE A.X = B.X AND A.Y = B.Y
       ORDER BY A.Y, B.X;

    SELECT MAX(X) INTO C.INFO.NCOL FROM TABLE(C.DATA);

    SELECT MAX(Y) INTO C.INFO.NROW FROM TABLE(C.DATA);

    RETURN C;

  END;

  FUNCTION MUL(A IN T_MATRIX, B IN T_MATRIX) RETURN T_MATRIX IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    C := MATRIX();

    IF NOT (NCOL(A) = NROW(B)) THEN
      RAISE MATRIX_ERROR;
    END IF;

    SELECT MATRIX_DATA_ROW(A.Y, B.X, SUM(A.VALUE * B.VALUE))
      BULK COLLECT
      INTO C.DATA
      FROM TABLE(A.DATA) A, TABLE(B.DATA) B
     WHERE A.X = B.Y
     GROUP BY A.Y, B.X
     ORDER BY A.Y, B.X;

    SELECT MAX(X) INTO C.INFO.NCOL FROM TABLE(C.DATA);

    SELECT MAX(Y) INTO C.INFO.NROW FROM TABLE(C.DATA);

    RETURN C;

  END;

  ---------------------------------------
  --
  -- MATRIX TRANSPOSE
  --
  --
  FUNCTION T(A IN T_MATRIX) RETURN T_MATRIX IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    C := MATRIX();

    SELECT MATRIX_DATA_ROW(X, Y, VALUE)
      BULK COLLECT
      INTO C.DATA
      FROM TABLE(A.DATA) A
     ORDER BY X, Y;

    SELECT MAX(X) INTO C.INFO.NCOL FROM TABLE(C.DATA);

    SELECT MAX(Y) INTO C.INFO.NROW FROM TABLE(C.DATA);

    RETURN C;

  END;
  FUNCTION RANK(A IN T_MATRIX, DIM IN INTEGER DEFAULT -1) RETURN NUMBER IS
    C            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    DIM_AUX      INTEGER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    IF A.INFO.NCOL > A.INFO.NROW THEN
      C := T(A);
    ELSE
      C := A;
    END IF;

    IF DIM = -1 THEN
      DIM_AUX := C.INFO.NCOL;
    ELSE
      DIM_AUX := DIM;
    END IF;

    FOR I IN 1 .. C.INFO.NROW - DIM_AUX + 1 LOOP
      FOR J IN 1 .. C.INFO.NCOL - DIM_AUX + 1 LOOP
        IF DET(CUT(C, I, J, I + DIM_AUX - 1, J + DIM_AUX - 1)) <> 0 THEN
          RETURN DIM_AUX;
        END IF;
      END LOOP;
    END LOOP;

    IF DIM <> 1 THEN
      RETURN RANK(C, DIM_AUX - 1);
    END IF;

    RETURN 1;
  END;

  FUNCTION MAX(A IN T_MATRIX) RETURN NUMBER IS
    MATRIX_ERROR EXCEPTION;
    MAXIMO       NUMBER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    MAXIMO := A.DATA(1).VALUE;
    FOR I IN 2 .. A.DATA.COUNT LOOP
      MAXIMO := GREATEST(A.DATA(I).VALUE, MAXIMO);
    END LOOP;
    RETURN MAXIMO;
  END;

  FUNCTION DIV(A IN T_MATRIX, B IN NUMBER) RETURN T_MATRIX IS
    MATRIX_ERROR EXCEPTION;
    MATRIX_OUT   T_MATRIX;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    MATRIX_OUT := MATRIX(NROW(A), NCOL(A), 0);

    FOR I IN 1 .. A.INFO.NROW LOOP
      FOR J IN 1 .. A.INFO.NCOL LOOP

        ASSIGN(MATRIX_OUT, I, J, GET(A, I, J) / B);

      END LOOP;
    END LOOP;

    RETURN MATRIX_OUT;
  END;

  FUNCTION DIV(A IN T_MATRIX, B IN T_MATRIX) RETURN T_MATRIX IS
    MATRIX_ERROR EXCEPTION;
    MATRIX_OUT   T_MATRIX;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    IF NOT (NCOL(A) = NCOL(B) AND NROW(A) = NROW(B)) THEN
      RAISE MATRIX_ERROR;
    END IF;

    MATRIX_OUT := MATRIX(NROW(A), NCOL(B), 0);

    FOR I IN 1 .. A.INFO.NROW LOOP
      FOR J IN 1 .. A.INFO.NCOL LOOP

        ASSIGN(MATRIX_OUT, I, J, GET(A, I, J) / GET(B, I, J));

      END LOOP;
    END LOOP;

    RETURN MATRIX_OUT;
  END;

  FUNCTION MIN(A IN T_MATRIX) RETURN NUMBER IS
    MATRIX_ERROR EXCEPTION;
    MINIMO       NUMBER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    MINIMO := A.DATA(1).VALUE;
    FOR I IN 2 .. A.DATA.COUNT LOOP
      MINIMO := LEAST(A.DATA(I).VALUE, MINIMO);
    END LOOP;
    RETURN MINIMO;
  END;

  FUNCTION TRUNC(A IN T_MATRIX) RETURN T_MATRIX IS
    MATRIX_ERROR EXCEPTION;
    M_OUT        T_MATRIX;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    M_OUT := A;
    FOR I IN 1 .. M_OUT.DATA.COUNT LOOP
      ASSIGN(M_OUT,
             M_OUT.DATA(I).Y,
             M_OUT.DATA(I).X,
             TRANCAR(M_OUT.DATA(I).VALUE, 0));
    END LOOP;
    RETURN M_OUT;
  END;

  FUNCTION COUNT(A IN T_MATRIX) RETURN NUMBER IS
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN A.DATA.COUNT;
  END;


  FUNCTION STD(A IN T_MATRIX) RETURN NUMBER IS
    MATRIX_ERROR EXCEPTION;
    MEDIA         NUMBER;
    PASO_1         NUMBER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    MEDIA := PCK_MATRIX.AVG(A);
    PASO_1 := 0;
    FOR I IN 1 .. A.DATA.COUNT LOOP
      PASO_1 := PASO_1 + ((A.DATA(I).VALUE - MEDIA) * (A.DATA(I).VALUE - MEDIA)) ;
    END LOOP;
    RETURN SQRT(PASO_1 / A.DATA.COUNT) ;
  END;

  FUNCTION SUM(A IN T_MATRIX) RETURN NUMBER IS
    MATRIX_ERROR EXCEPTION;
    SUMA         NUMBER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    SUMA := 0;
    FOR I IN 1 .. A.DATA.COUNT LOOP
      SUMA := A.DATA(I).VALUE + SUMA;
    END LOOP;
    RETURN SUMA;
  END;

  FUNCTION PROD(A IN T_MATRIX) RETURN NUMBER IS
    MATRIX_ERROR EXCEPTION;
    SUMA         NUMBER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    SUMA := 1;
    FOR I IN 1 .. A.DATA.COUNT LOOP
      SUMA := A.DATA(I).VALUE * SUMA;
    END LOOP;
    RETURN SUMA;
  END;

  FUNCTION MEAN(A IN T_MATRIX) RETURN NUMBER IS
    MATRIX_ERROR EXCEPTION;
    SUMA         NUMBER;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN
    RETURN PCK_MATRIX.SUM(A) / A.DATA.COUNT;
  END;

  FUNCTION AVG(A IN T_MATRIX) RETURN NUMBER IS
    MATRIX_ERROR EXCEPTION;

    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
  BEGIN

    RETURN PCK_MATRIX.SUM(A) / A.DATA.COUNT;
  END;

  ---------------------------------------
  --
  -- MATRIX DET
  --
  --
  FUNCTION DET(A IN T_MATRIX, K IN INTEGER) RETURN NUMBER IS
    B            T_MATRIX;
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
    --K   INTEGER;
    I           INTEGER;
    J           INTEGER;
    M           INTEGER;
    N           INTEGER;
    C           INTEGER;
    DETERMINANT NUMBER;
    S           NUMBER;
  BEGIN
    B := MATRIX(K, K);
    -- K   := NCOL(A);
    S           := 1;
    DETERMINANT := 0;

    IF NOT (NCOL(A) = NROW(A)) THEN
      RAISE MATRIX_ERROR;
    END IF;

    IF (K = 1) THEN
      RETURN GET(A, 0 + 1, 0 + 1);
    ELSE

      BEGIN
        DETERMINANT := 0;
        FOR C IN 0 .. K - 1 LOOP
          BEGIN
            M := 0;
            N := 0;
            FOR I IN 0 .. K - 1 LOOP
              BEGIN
                FOR J IN 0 .. K - 1 LOOP
                  BEGIN
                    ASSIGN(B, (I + 1), (J + 1), 0);
                    IF (I != 0 AND J != C) THEN
                      BEGIN
                        ASSIGN(B, M + 1, N + 1, GET(A, I + 1, J + 1));
                        IF (N < (K - 2)) THEN
                          N := N + 1;
                        ELSE
                          BEGIN
                            N := 0;
                            M := M + 1;
                          END;
                        END IF;
                      END;
                    END IF;
                  END;
                END LOOP;
              END;
            END LOOP;
            DETERMINANT := DETERMINANT +
                           S * (GET(A, 0 + 1, C + 1) * DET(B, K - 1));
            S           := -1 * S;
          END;
        END LOOP;
      END;

    END IF;

    RETURN DETERMINANT;

  END;

  ---------------------------------------
  --
  -- MATRIX DET
  --
  --
  FUNCTION DET(A IN T_MATRIX) RETURN NUMBER IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);

  BEGIN

    IF NOT (NCOL(A) = NROW(A)) THEN
      RAISE MATRIX_ERROR;
    END IF;

    RETURN DET(A, NCOL(A));

  END;

  ---------------------------------------
  --
  -- MATRIX INVERSE
  --
  --
  FUNCTION INV(B IN T_MATRIX) RETURN T_MATRIX IS
    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);
    A T_MATRIX;
    K INTEGER;

    RATIO NUMBER;
    I     INTEGER;
    J     INTEGER;
    N     INTEGER;
  BEGIN

    IF NOT (NCOL(B) = NROW(B)) THEN
      RAISE MATRIX_ERROR;
    END IF;

    N := NCOL(B);

    A := EXTEND(B, N, N + N);

    /* AUGMENTING IDENTITY MATRIX OF ORDER N */
    FOR I IN 1 .. N LOOP
      FOR J IN 1 .. N LOOP
        IF (I = J) THEN
          ASSIGN(A, I, J + N, 1);
        ELSE
          ASSIGN(A, I, J + N, 0);
        END IF;
      END LOOP;
    END LOOP;

    /* APPLYING GAUSS JORDAN ELIMINATION */
    FOR I IN 1 .. N LOOP

      IF (GET(A, I, I) = 0) THEN
        RAISE MATRIX_ERROR; --('Mathematical Error!');
      END IF;

      FOR J IN 1 .. N LOOP
        IF (I != J) THEN
          RATIO := GET(A, J, I) / GET(A, I, I);
          FOR K IN 1 .. (N * 2) LOOP
            ASSIGN(A, J, K, GET(A, J, K) - (RATIO * GET(A, I, K)));
          END LOOP;
        END IF;
      END LOOP;
    END LOOP;

    /* ROW OPERATION TO MAKE PRINCIPAL DIAGONAL TO 1 */
    FOR I IN 1 .. N LOOP
      FOR J IN N + 1 .. (2 * N) LOOP
        ASSIGN(A, I, J, GET(A, I, J) / GET(A, I, I));
      END LOOP;
    END LOOP;
    RETURN CUT(A, 1, NCOL(A) / 2 + 1, NROW(A), NCOL(A));
  END;

  ---------------------------------------
  --
  -- MATRIX TRANSPOSE
  --
  --
  FUNCTION LRE(X IN T_MATRIX, Y IN T_MATRIX) RETURN T_MATRIX IS

    MATRIX_ERROR EXCEPTION;
    PRAGMA EXCEPTION_INIT(MATRIX_ERROR, -20001);

    B            T_MATRIX;
    TX_X         T_MATRIX;
    TX_X_INV     T_MATRIX;
    TX_X_INV_T   T_MATRIX;
    TX_X_INV_T_Y T_MATRIX;

  BEGIN

    TX_X := PCK_MATRIX.MUL(PCK_MATRIX.T(X), X);

    TX_X_INV := PCK_MATRIX.INV(TX_X);

    TX_X_INV_T := PCK_MATRIX.MUL(TX_X_INV, PCK_MATRIX.T(X));

    TX_X_INV_T_Y := PCK_MATRIX.MUL(TX_X_INV_T, Y);

    B := TX_X_INV_T_Y;

    RETURN B;

  END;

BEGIN
  NULL;
END NO;
/
